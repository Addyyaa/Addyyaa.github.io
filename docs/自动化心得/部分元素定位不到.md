高频成因（按命中率排序）

1. 分层渲染：元素压根在“另一个 WebView”

- uni-app/5+ 的常见架构：父子 WebView、多子 WebView 布局（例如头部/底部在父或子窗口，内容页在子窗口）。
- 你在当前 WEBVIEW 打印 DOM 看不到“fixed”节点，很可能它在另一个 WEBVIEW_xxx。
- 现象：driver.contexts 会有多个 WEBVIEW；切换到“对的那个”才能在 pageSource 里看到节点。

1. 被“原生层”实现（没有 DOM）

- subNVue：独立的原生窗口，显示在 WebView 之上；没有 DOM 节点可供抓取。
- plus.nativeObj.View：用原生画布绘制的视图/文本/形状，完全没有可访问节点。
- 原生标题栏/TabBar（titleNView/tabBar）：App 端使用原生实现，也不在 DOM。
- 现象：无论切 NATIVE_APP 还是 WEBVIEW 都可能看不到“可用节点”（有时 NATIVE 树里也没有可抓取的可访问性控件，只是纯绘制）。

1. nvue 页面（Weex 原生渲染）

- nvue 页面本质是原生组件树，不是 H5 DOM；“fixed”由原生布局完成。
- 现象：该页没有 WEBVIEW 上下文；需要在 NATIVE_APP 下定位，且要有可访问性标识才容易抓。

1. 组件库/弹层用原生实现

- 常见弹层、遮罩、ActionSheet、Toast、导航、吸顶等，为性能在 App 端走原生或子 WebView。
- 现象：H5 里看不到；只能在对应上下文（另一个 WEBVIEW 或 NATIVE）操作，或压根没节点可抓。

1. 运行期结构调整/虚拟化

- 有些组件在挂载后将“fixed”内容移动到全局顶层容器或独立子窗口；或者 v-if 条件未满足导致未挂载。
- 现象：DOM 里根本没有该节点或在别的容器/上下文。

怎么自证你遇到的是哪一种

- 列出并切换上下文
  - 在 Appium 里打印 driver.contexts；逐个切换到 WEBVIEW_xxx 和 NATIVE_APP，分别 getPageSource 搜索该元素标识。
- App 侧查看子 WebView
  - 调试版注入：
    document.addEventListener('plusready', () => {
    const wv = plus.webview.currentWebview();
    console.log('children:', wv.children()); // 有子 webview 基本就多上下文
    });
- 检查项目配置/用到的能力
  - pages.json 是否配置了 titleNView/tabBar/subNVUE；
  - 是否是 nvue 页面；
  - 是否引入了使用 subNVue/nativeObj 的弹层/导航类组件。

定位与规避方案

- 元素在“另一个 WEBVIEW”
  - 解决：切换到正确的 WEBVIEW_xxx 再定位；确保 Android 调试内核和 Chromedriver 匹配，否则 WEBVIEW 列表拿不到。
- 是原生层（subNVue/nativeObj/titleNView/tabBar）
  - 解决优先级：
    1. 测试专用包把该层改为同 WebView 的 DOM 实现（最稳）；
    2. 改为 nvue 的原生控件并给可访问性标识（Android: contentDescription；iOS: accessibilityLabel），走 NATIVE 定位；
    3. 无法改造时，用坐标点击/图像识别兜底（需适配分辨率，稳定性差）。
- 整页是 nvue
  - 解决：走 NATIVE_APP；为关键控件补可访问性标识，必要时开启元素边界/可访问性检查。
- 不想动业务代码？可以用同 WebView 内“绝对定位”来模拟 fixed
  - 思路：整页容器 position: relative；头/底/悬浮按钮用 absolute，滚动放进中间的 scroll-view 容器，这样所有元素都在同一 DOM/WebView，Appium 在该 WEBVIEW 下可见。
- 自动化工程化建议
  - 为 WebView 元素加 data-test-id；
  - 为原生控件加可访问性属性；
  - 封装“上下文轮询定位器”（依次尝试 NATIVE_APP + 所有 WEBVIEW_xxx）；
  - 必要时构建“自动化友好版”包：减少原生层、开放 WebView 调试、对 subNVue 注入可访问性。

对应资料与文档（便于你自行核对）

- nvue 是原生渲染，不是 H5 DOM
  - uni-app 文档：nvue 概览/特性（说明原生渲染、CSS 子集）
  - https://uniapp.dcloud.net.cn/tutorial/nvue/
- subNVue：独立原生窗口，覆盖在 WebView 之上
  - API 文档明确“位于原生层之上、非 DOM”
  - https://uniapp.dcloud.net.cn/api/window/subNVUE.html
- plus.nativeObj.View：原生画布视图（无 DOM）
  - 5+ 文档：原生绘制视图叠加于 WebView
  - https://www.html5plus.org/doc/zh_cn/nativeobj.html#plus.nativeObj.View
- titleNView/tabBar：App 端为原生实现
  - pages.json 配置说明
  - https://uniapp.dcloud.net.cn/collocation/pages.html#titlenview
  - https://uniapp.dcloud.net.cn/collocation/pages.html#tabbar
- Appium WebView/NATIVE 多上下文
  - 需要切换 context 才能看到对应元素树
  - https://appium.io/docs/en/2.0/guides/web/hybrid/

快速判定/解决清单

- 打印 driver.contexts，逐个切换看 pageSource；
- 在页面 plusready 后打印 currentWebview().children()；
- 检查是否使用 nvue/subNVue/titleNView/tabBar/nativeObj；
- 若确系原生层：添加可访问性或改为同 WebView 的 DOM 实现；
- 不行就坐标/图像识别兜底，并做分辨率适配。

如果你愿意，把：

- 该页是 App-Vue 还是 nvue；
- driver.contexts 输出、每个上下文下的 pageSource 搜索结果；
- 是否用了 titleNView/subNVue/某个弹层组件；
  贴出来，我可以帮你判断具体是哪一类，并给出最省改造的落地方案。